require(sna)
require(ergm)
data
str(data)
str(mymat)
mymat
str(nch)
source("./functions/bip_init_network.R")
source("./functions/bip_init_igraph.R")
nch.net <- bip_init_network(nch)
hr.net <- bip_init_network(hr)
source("./functions/bip_binplot.R")
source("./functions/bip_gplot.R")
source("./functions/bip_qtplot.R")
source("./functions/vectorize.R")
require(network)
require(ggplot2)
require(sna)
require(ergm)
mymat <- nch
net <- nch.net
source("bip_ggplot2.R")
#
# We repeat for the Hato Raton network.
mymat <- hr
net <- hr.net
source("bip_ggplot2.R")
require(downloader)
#
# PJ example. Based on a gist by F Briatte to just feed the network data
# from its adjacency matrix to ggnet
#-------------------------------------------------------------------------
link = "https://raw.github.com/pedroj/bipartite_plots/master/data/NCH_quant_bmatrix.txt"
file = "data/NCH_quant_bmatrix.txt"
if(!file.exists(file)) download(link, file, mode = "wb")
M <- read.table(file, sep = "\t", dec = ",", header = TRUE, row.names = 1)
# ...
# Bipartite network initialization, starting from a weighted adjacency matrix.
# ...
source("functions/bip_briatte.R")
source_url("https://raw.github.com/briatte/ggnet/master/ggnet.R", prompt = FALSE)
# ...
# Pass the network, edge weights and mode to ggnet.
# ...
net = bipartite.network(M, modes = c("Animals", "Plants"))
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35,
label = TRUE, color = "black",
node.group = get.vertex.attribute(net, "mode"))
M
net = bipartite.network(M, modes = c("Animals", "Plants"))
net
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35,
label = TRUE, color = "black",
node.group = get.vertex.attribute(net, "mode"))
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35,
# label = TRUE, color = "black",
node.group = get.vertex.attribute(net, "mode"))
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35)
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35)
View(hr)
ggnet
library(ggplot2)
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35)
?arrow
??arrow
library(diagram)
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .35)
ggnet
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .25,
label = TRUE, color = "black",
node.group = get.vertex.attribute(net, "mode"))
ggnet<-function(
net,                          # an object of class network
mode             = "fruchtermanreingold", # placement algorithm
layout.par       = NULL,      # placement options
size             = 12,        # node size
alpha            = .75,       # transparency
weight.method    = "none",    # what to weight the nodes with: "freeman", "indegree", "outdegree"
names            = c("", ""), # what to call the node color and node weight legends
node.group       = NULL,      # what to color the nodes with
node.color       = NULL,      # what colors to use for the node classes
node.alpha       = NULL,      # transparency for nodes (inherits from alpha)
segment.alpha    = NULL,      # transparency for links (inherits from alpha)
segment.color    = "grey",    # default links are rgb(190, 190, 190)
segment.label    = NULL,      # label network at mid-edges
segment.size     = .25,       # set to 0 to remove from plot
arrow.size       = 0,         # set to 0 to remove from plot
label.nodes      = FALSE,     # add vertex names in small print; can be a list of vertex names
label.size       = size / 2,         # size of the vertex names
top8.nodes       = FALSE,     # color the top 8 nodes by weighting method with ColorBrewer Set1
trim.labels      = TRUE,      # clean vertex names
quantize.weights = FALSE,     # break weights to quartiles
subset.threshold = 0,         # what nodes to exclude, based on weight.method â‰¥ subset
geo.outliers = TRUE,          # when mode = "geo", trim geographic outliers
legend.position  = "right",   # set to "none" to remove from plot
...                           # passed to geom_text for node labels
){
require(intergraph   , quietly = TRUE) # igraph conversion
require(network      , quietly = TRUE) # vertex attributes
require(RColorBrewer , quietly = TRUE) # default colors
require(sna          , quietly = TRUE) # placement algorithm
# support for igraph objects
if(class(net) == "igraph") {
net = asNetwork(net)
}
if(class(net) != "network")
stop("net must be a network object of class 'network' or 'igraph'")
# vertex attributes for weight detection
vattr = network::list.vertex.attributes(net)
# get arguments
weight    = c("indegree", "outdegree", vattr)
weight    = ifelse(weight.method %in% weight | length(weight.method) > 1,
weight.method, "freeman")
quartiles = quantize.weights
labels    = label.nodes
# alpha default
inherit <- function(x) ifelse(is.null(x), alpha, x)
# subset
if(subset.threshold > 0) {
network::delete.vertices(
net,
which(sna::degree(net, cmode = weight) < subset.threshold))
}
# get sociomatrix
m <- as.matrix.network.adjacency(net)
if(mode == "geo" & all(c("lat", "lon") %in% vattr)) {
plotcord = data.frame(
X1 = as.numeric(net %v% "lon"),
X2 = as.numeric(net %v% "lat")
)
# remove outliers
if(geo.outliers) {
plotcord$X1[ abs(plotcord$X1) > quantile(abs(plotcord$X1), .9, na.rm = TRUE) ] = NA
plotcord$X2[ is.na(plotcord$X1) | abs(plotcord$X2) > quantile(abs(plotcord$X2), .9, na.rm = TRUE) ] = NA
plotcord$X1[ is.na(plotcord$X2) ] = NA
}
} else {
# get coordinates placement algorithm
placement <- paste0("gplot.layout.", mode)
if(!exists(placement)) stop("Unsupported placement method.")
plotcord <- do.call(placement, list(m, layout.par))
plotcord <- data.frame(plotcord)
colnames(plotcord) = c("X1", "X2")
}
# get edgelist
edglist <- as.matrix.network.edgelist(net)
edges   <- data.frame(plotcord[edglist[, 1], ], plotcord[edglist[, 2], ])
# get node groups
if(!is.null(node.group)) {
network::set.vertex.attribute(net, "elements", as.character(node.group))
plotcord$group <- as.factor(network::get.vertex.attribute(net, "elements"))
}
# get node weights
degrees <- data.frame(
id        = network.vertex.names(net),
indegree  = sapply(net$iel, length),
outdegree = sapply(net$oel, length)
)
degrees$freeman <- with(degrees, indegree + outdegree)
# custom weights: vector of weights
if(length(weight.method) == network.size(net)) {
degrees$user = weight.method
weight = "user"
}
# custom weights: vertex attribute
if(weight.method %in% vattr) {
degrees$user = net %v% weight.method
names(degrees)[ ncol(degrees) ] = weight.method
weight = weight.method
}
# trim vertex names
if(trim.labels) {
degrees$id = gsub("@|http://|www.|/$", "", degrees$id)
}
# set top 8 nodes as groups
if(top8.nodes) {
all                  = degrees[, weight]
top                  = degrees$id[order(all, decreasing = TRUE)[1:8]]
top                  = which(degrees$id %in% top)
plotcord$group       = as.character(degrees$id)
plotcord$group[-top] = paste0("(", weight, " > ", subset.threshold - 1, ")")
node.group           = plotcord$group
node.color           = brewer.pal(9, "Set1")[c(9, 1:8)]
}
colnames(edges) <- c("X1", "Y1", "X2", "Y2")
# set vertex names
plotcord$id <- as.character(degrees$id)
if(is.logical(labels)) {
if(!labels) {
plotcord$id = ""
}
} else {
plotcord$id[ -which(plotcord$id %in% labels) ] = ""
}
# get vertice midpoints (not -yet- used later on)
edges$midX  <- (edges$X1 + edges$X2) / 2
edges$midY  <- (edges$Y1 + edges$Y2) / 2
# plot the network
pnet <- ggplot(plotcord, aes(X1, X2)) +
# plot vertices (links)
geom_segment(
aes(x = X1, y = Y1, xend = X2, yend = Y2),
data   = edges,
size   = segment.size,
colour = segment.color,
alpha  = inherit(segment.alpha),
arrow  = curvedarrow(
type   = "closed",
length = unit(arrow.size, "cm")
)
# label mid-edges
if(!is.null(segment.label) & length(segment.label) == nrow(edges)) {
pnet <- pnet + geom_text(
aes(x = midX, y = midY),
data   = edges,
label = segment.label,
size = 1 / segment.size, # fixed setting
colour = segment.color,
alpha  = inherit(segment.alpha)
)
}
# null weighting
if(weight.method == c("none")) {
pnet <- pnet + geom_point(
data  = plotcord,
alpha = inherit(node.alpha),
size  = size
)
}
else {
plotcord$weight <- degrees[, weight ]
# show top weights
cat(nrow(plotcord), "nodes, weighted by", weight, "\n\n")
print(head(degrees[ order( -degrees[weight] ), ]))
# proportional scaling
sizer <- scale_size_area(names[2], max_size = size)
# quartiles
if(quartiles) {
plotcord$weight.label <- cut(
plotcord$weight,
breaks         = quantile(plotcord$weight),
include.lowest = TRUE,
ordered        = TRUE
)
plotcord$weight <- as.integer(plotcord$weight.label)
sizer <- scale_size_area(
names[2],
max_size = size,
labels   = levels(plotcord$weight.label)
)
}
# add to plot
pnet <- pnet + geom_point(
aes(size = weight),
data  = plotcord,
alpha = inherit(node.alpha)
) + sizer
}
# default colors
n = length(unique(suppressWarnings(na.omit(node.group))))
if(length(node.color) != n & !is.null(node.group)) {
warning("Node groups and node colors are of unequal length; using default colors.")
if(n > 0 & n < 10) {
node.color = brewer.pal(9, "Set1")[1:n]
}
# color the nodes
if(!is.null(node.group)) {
pnet <- pnet +
aes(colour = group) +
scale_colour_manual(
names[1],
values = node.color,
guide  = guide_legend(override.aes = list(size = label.size))
)
}
# add text labels
if(length(unique(plotcord$id)) > 1 | unique(plotcord$id)[1] != "") {
pnet <- pnet + geom_text(aes(label = id), size = label.size, ...)
}
# finalize: remove grid, axes and scales
pnet <- pnet +
scale_x_continuous(breaks = NULL) +
scale_y_continuous(breaks = NULL) +
theme(
panel.background = element_rect(fill = "white"),
panel.grid       = element_blank(),
axis.title       = element_blank(),
legend.key       = element_rect(colour = "white"),
legend.position  = legend.position
)
return(pnet)
}
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .25,
label = TRUE, color = "black",
node.group = get.vertex.attribute(net, "mode"))
ggnet(net,
segment.size = edge.weights(M, 15), segment.alpha = .25)
q()
library(sna)
?sna
g<-rgraph(10)     #Draw a random graph with 10 members
closeness(g)
g<-rgraph(10)     #Draw a random graph with 10 members
closeness(g)
g
connectedness(g)
plot(g)
library(igraph)
?igraph
g
gg<- graph.adjacency(g)
plot(gg)
gg
closeness(gg)
library("ggnet", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("ggnetwork", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
detach("package:ggnet", unload=TRUE)
detach("package:ggnetwork", unload=TRUE)
library("ggnetwork", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("ggnet", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library("GGally", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
data(mtcars)
ggally_points(mtcars, mapping = ggplot2::aes(x = disp, y = hp))
library(multigraph)
arr <- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
c(3,3,2))>.5, 3 ) )
bmgraph(arr)
bmgraph
arr
?bmgraph
bmgraph(arr, layout= "bip3")
bmgraph(arr, layout= "bip3", cex=2)
bmgraph(arr, layout= "bip3", cex=4)
bmgraph(arr, layout= "bip3", cex=3)
bmgraph(arr, layout= "bip3", cex=3,
vcol= c(rep("red",3), rep("blue",3))
bmgraph(arr, layout= "bip3", cex=3,
vcol= c(rep("red",3), rep("blue",3))
)
bmgraph(arr, layout= "bip3", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "bip4", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "force", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "force", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "force", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "force", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "CA", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "CA", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "CA", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
bmgraph(arr, layout= "bip3e", cex=3,
vcol= c(rep("red",3), rep("blue",3)))
nch <- read.table("./data-raw/NCH_quant_bmatrix.txt",
header=T, sep="\t", row.names=1,
dec=",", na.strings="NA")
hr <- read.table("./data-raw/HR_quant_bmatrix.txt",
header=T, sep="\t", row.names=1,
dec=".", na.strings="NA")
source("./R/bip_init_network.R")
source("./R/bip_init_igraph.R")
nch.net <- bip_init_network(nch)
hr.net <- bip_init_network(hr)
source("./R/bip_init_network.R")
source("./R/bip_init_igraph.R")
nch.net <- bip_init_network(nch)
bip_init_network <- function (mymat, modes= c("A", "P")) {
require(network)
require(ggnet)
if(!is.matrix(mymat)) mymat <- as.matrix(mymat)
a<- dim(mymat)[1]    # Animals are rows
p<- dim(mymat)[2]    # Plants are columns
net<- network(mymat,
matrix.type = "bipartite",
ignore.eval = FALSE,
#             names.eval = "weights")
names.eval=list(row.names(mymat), colnames(mymat)))
}
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_init_network.R', echo=TRUE)
mymat <- read.table(pipe("pbpaste"), header=T, sep= "\t", row.names=1)
test.net<- bip_init_network(mymat)
test.net
plot(test.net)
nch.net <- bip_init_network(nch)
hr.net <- bip_init_network(hr)
source("./R/bip_init_network.R")
source("./R/bip_init_igraph.R")
test.net<- bip_init_network(mymat)
nch.net <- bip_init_network(nch)
hr.net <- bip_init_network(hr)
test.net<- bip_init_network(mymat)
hr.net <- bip_init_network(hr)
nch.net <- bip_init_network(nch)
hr.net <- bip_init_network(hr)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_init_igraph.R', echo=TRUE)
source("./R/bip_init_igraph.R")
test.ig<- bip_init_igraph(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
ls()
bip_qtplot(mymat)
?network.bipartite
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
?RColorBrewer
display.brewer.all(n=NULL, type="all", select=NULL, exact.n=TRUE,
colorblindFriendly=FALSE)
brewer.pal.info
display.brewer.pal()
display.brewer.pal(Pastel1)
display.brewer.pal("Pastel1")
display.brewer.all()
brewer.pal.info["Blues",]
brewer.pal.info["Blues",]$maxcolors
display.brewer.all(type="seq")
display.brewer.all(type="qual")
devAskNewPage(ask=TRUE)
mypalette<-brewer.pal(7,"Greens")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Greens (sequential)",
ylab="",xaxt="n",yaxt="n",bty="n")
mypalette$names
str(mypalette)
display.brewer.pal(7,"BrBG")
display.brewer.pal(7,"Accent")
mypalette
mypalette<-brewer.pal(7,"Greens")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Greens (sequential)",
ylab="",xaxt="n",yaxt="n",bty="n")
mypalette
mypalette<-brewer.pal(7,"Reds")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Greens (sequential)",
ylab="",xaxt="n",yaxt="n",bty="n")
mypalette
mypalette<-brewer.pal(7,"Blues")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Greens (sequential)",
ylab="",xaxt="n",yaxt="n",bty="n")
mypalette
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
mypalette<-brewer.pal(7,"Greys")
image(1:7,1,as.matrix(1:7),col=mypalette,xlab="Greens (sequential)",
ylab="",xaxt="n",yaxt="n",bty="n")
mypalette
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
devAskNewPage(ask=F)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
?plot.network
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R')
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R')
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R', echo=TRUE)
bip_qtplot(mymat)
ls()
bip_qtplot(nch.net)
M
bip_qtplot(M)
source('~/Documents/Working/~RCode/MyRCode/networks/bipartite_plots/R/bip_qtplot.R')
bip
bip= data.frame(P1= c(1, 2, 1, 0),
P2= c(0, 0, 3, 0),
P3= c(1, 1, 0, 4),
row.names= letters[1:4])
bip_qtplot(bip)
bip= data.frame(P1= c(1, 12, 6, 0),
P2= c(1, 0, 4, 0),
P3= c(1, 7, 3, 12),
row.names= letters[1:4])
bip_qtplot(bip)
